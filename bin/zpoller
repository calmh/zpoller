#!/usr/bin/env node

var _ = require('underscore');
var Log = require('log'), log = new Log('debug', process.stderr);
var config = require('../lib/config');
var db = require('../lib/db');
var q = require('promised-io');
var tm = require('../lib/targetmaker');
var util = require('util');

config.load(main);

function maxConfigChanged(collection) {
    var d = q.defer();
    collection.mapReduce(function() { emit ('maxCreated', this.created) }, function (key, arr) { return Math.max.apply(null, arr); }, { out: { inline: 1 }, safe: true }, function (err, res) {
        if (err) {
            return d.reject(err);
        }
        if (res.length === 1) {
            d.resolve(res[0].value);
        } else {
            d.resolve(0);
        }
    });
    return d.promise;
}

function hostsToIndex() {
    var d = q.defer();

    var pclient = _.bind(q.convertNodeAsyncFunction(db.client), db);
    pclient().then(function (client) {
        var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

        var changeDate = pcollection('config').then(function (coll) {
            return maxConfigChanged(coll);
        });

        changeDate.then(function (cd) {
            pcollection('hosts').then(function (coll) {
                var q = { indexed: { $lte: cd } }; // Configuration has changed since last index
                var f = { name: 1, ip: 1, community: 1 };
                coll.find(q, f, { safe: true }).toArray(function (err, hs) {
                    d.resolve(hs);
                    client.close();
                });
            });
        });
    });

    return d.promise;
}

function getPackages() {
    var pclient = _.bind(q.convertNodeAsyncFunction(db.client), db);
    var pkgs = pclient().then(function (client) {
        var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

        return pcollection('config').then(function (coll) {
            var d = q.defer();

            coll.find().toArray(function (err, pkgs) {
                d.resolve(pkgs);
                client.close();
            });

            return d.promise;
        });
    });
    return pkgs;
}

function updateTargets(res) {
    var pclient = _.bind(q.convertNodeAsyncFunction(db.client), db);
    pclient().then(function (client) {
        var updates = [];
        var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

        pcollection('targets').then(function (coll) {
            var pupdate = _.bind(q.convertNodeAsyncFunction(coll.update), coll);
            _.each(res, function (host) {
                _.each(host.interfaces, function (ifData, ifName) {
                    log.debug('Updating target for host: ' + host.name + ', interface: ' + ifName);
                    updates.push(pupdate({ host: host.name, interface: ifName }, { $set: ifData }, { safe: true, upsert: true }));
                });
            });
        });

        pcollection('hosts').then(function (coll) {
            var pupdate = _.bind(q.convertNodeAsyncFunction(coll.update), coll);
            _.each(res, function (host) {
                log.debug('Updating host record for host: ' + host.name);
                updates.push(pupdate({ name: host.name }, { $set: { indexed: host.indexed, uptimeWhenIndexed: host.uptimeWhenIndexed } }, { safe: true }));
            });
        });

        q.all(updates).then(function () {
            client.close();
        });
    });
}

function main() {
    hostsToIndex().then(function (hosts) {
        var pkgs, res;

        if (hosts.length > 0) {
            log.info('Going to reindex ' + hosts.length + ' hosts.');
            getPackages().then(function (pkgs) {
                return tm.mapHosts(hosts, pkgs);
            }).then(updateTargets);
        }
    });
}

// vim: set ft=javascript:
