#!/usr/bin/env node

var _ = require('underscore');
var config = require('../lib/config');
var db = require('../lib/db');
var q = require('promised-io');
var tm = require('../lib/targetmaker');
var util = require('util');

config.load(main);

function maxConfigChanged(collection) {
    var d = q.defer();
    collection.mapReduce(function() { emit ('maxCreated', this.created) }, function (key, arr) { return Math.max.apply(null, arr); }, { out: { inline: 1 }, safe: true }, function (err, res) {
        if (err) {
            return d.reject(err);
        }
        if (res.length === 1) {
            d.resolve(res[0].value);
        } else {
            d.resolve(0);
        }
    });
    return d.promise;
}

function hostsToIndex() {
    var d = q.defer();

    var pclient = _.bind(q.convertNodeAsyncFunction(db.client), db);
    pclient().then(function (client) {
        var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

        var changeDate = pcollection('config').then(function (coll) {
            return maxConfigChanged(coll);
        });

        changeDate.then(function (cd) {
            pcollection('hosts').then(function (coll) {
                var q = { indexed: { $lte: cd } }; // Configuration has changed since last index
                var f = { name: 1, ip: 1, community: 1 };
                coll.find(q, f, { safe: true }).toArray(function (err, hs) {
                    d.resolve(hs);
                    client.close();
                });
            });
        });
    });

    return d.promise;
}

function main() {
    var pclient = _.bind(q.convertNodeAsyncFunction(db.client), db);

    hostsToIndex().then(function (hosts) {
        var pkgs, res;

        if (hosts.length > 0) {
            pkgs = pclient().then(function (client) {
                var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

                return pcollection('config').then(function (coll) {
                    var d = q.defer();

                    coll.find().toArray(function (err, pkgs) {
                        d.resolve(pkgs);
                        client.close();
                    });

                    return d.promise;
                });
            });

            res = pkgs.then(function (pkgs) {
                return tm.mapHosts(hosts, pkgs);
            });

            res.then(function (res) {
                console.log(res);
                pclient().then(function (client) {
                    var updates = [];
                    var pcollection = _.bind(q.convertNodeAsyncFunction(client.collection), client);

                    pcollection('hosts').then(function (coll) {
                        var pupdate = _.bind(q.convertNodeAsyncFunction(coll.update), coll);
                        _.each(res, function (host) {
                            updates.push(pupdate({ name: host.name }, { $set: { indexed: host.indexed, uptimeWhenIndexed: host.uptimeWhenIndexed } }, { safe: true }));
                        });
                    });

                    pcollection('targets').then(function (coll) {
                        var pupdate = _.bind(q.convertNodeAsyncFunction(coll.update), coll);
                        _.each(res, function (host) {
                            _.each(host.interfaces, function (ifData, ifName) {
                                updates.push(pupdate({ host: host.name, interface: ifName }, { $set: ifData }, { safe: true, upsert: true }));
                            });
                        });
                    });

                    q.all(updates).then(function () {
                        client.close();
                    });
                });
            });
        }
    });
/*
    var hosts = q.defer();
    var packages = q.defer();


        pcollection('hosts').then(function (coll) {
            coll.find().toArray(function (err, hs) {
                _.each(hs, function (h) {
                    delete h._id;
                    delete h.created;
                });
                hosts.resolve(hs);
            });
        });

        q.all(hosts, packages).then(function () {
            client.close();
        });
    });

    hosts.then(function (hs) {
        tm.getUptimes(hs).then(function (uptimes) {
            console.log(uptimes);
        });
    });

    q.all(hosts, packages).then(function (arr) {
        var hosts = arr[0];
        var pkgs = arr[1];
        tm.mapHosts(hosts, pkgs).then(function (res) {
            console.log(util.inspect(res, false, null));
        });
    });*/
}

// vim: set ft=javascript:
